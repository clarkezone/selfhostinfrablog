[ { "title": "Using Okteto to run integration tests", "url": "/posts/integration-tests-okteto/", "categories": "kubernetes, testing", "tags": "okteto, devproductivity", "date": "2022-06-06 03:51:02 +0000", "snippet": "DRAFT4If you are doing development targeting Kubernetes, you will know that the inner loop can be challenging. The process is to typically work locally, create a image, push to a registry somewhere hopefully not too far away, update a kubernetes deployment manifest to point to the new version of the image, restart the deployment in the cluster, observe logs. All of this is time and friction for iterating fast.One of the additional challenges comes when the component you are developing is needs to not only run inside a cluster but also calls cluster API’s. An extreme case is when you are building an extension like an operator.To help improve the inner loop in scenarios such as these various solutions have sprung up to solve this kind of problem. One that I have looked into is Okteto. I plan on doing a more extensive post in this in the future, for now I wanted to share how I’ve been leverage Okteto as a means of running and debugging some of my unit and integration tests that test code that creates job resources on the fly by integrating with the cluster API.I’ve experimented with Okteto for a couple of use cases, firstly debugging code that integrates with the cluster API such as the job management logic. Secondly, using Okteto as a mechanism for running integration tests that depend on kubernetes.Challenges1) Unit tests require environment variables to be set. Those are currently not checked in, need to add .previewd_test.env2) In machine settings, need to alter the path to point to the location in tree (can settings use %USERPROFILE?)3) Because files are synced into Okteto, there is no git presense there hence need to hard code gitroot4) Tests don’t have an incluster mode hence necessary to hard code incluster mode5) Can’t start namespace watchers on either specific or default namespace. This may be because i need a cluster role binding7) Okteto cloud.. debugging takes around 10 seconds to start8) Assuming a simple test worked, the end-2-end integration test requires ReadWriteMany volumes. It’s possible this could be worked around by restructuring test to create a seperate clone job against a readwriteone PVC followed by the webhook update triggerThe overall conclusion at this point is that Okteto isn’t a good fit for this scenarioIf you are inteterested in following along, grab the prevewd repo. You can then try running one of the unit tests as follows: enable unit tests by editing machine config (not user config) and adding: { &quot;go.buildFlags&quot;: [ &quot;-tags=unit,integration&quot; ], &quot;go.buildTags&quot;: &quot;-tags=unit,integration&quot;, &quot;go.testTags&quot;: &quot;-tags=unit,integration&quot;} " }, { "title": "Case of the throttled daemonset", "url": "/posts/case-of-throttled-daemonset/", "categories": "Kubernetes, Troubleshooting", "tags": "favicon", "date": "2022-06-01 16:34:00 +0000", "snippet": "DRAFT4SituationI have two tiers of monitoring on my cluster.Around about late May 2022, an alert started firing.TaskTheory: too conservative limits for node explorer. The approach I came up with to confirm theory and fix alert: Observe the problem in the cluster and understand exactly what is throttled and by how much. In the process get my head round CPU reests / limis in particular what the various numbers and percentages actually mean Confirm understanding by changing limits to confirm I’ve pinpointed the correct entity and values. Find root cause.. what is putting load on the node exporter to cause it to exceed limitActionObserve problem and understand:Confirm understanding by changing limits:First thing I tried was to increase first the ammount of CPU requested and second the limit:diff --git a/manifests/monitoring/manifests/nodeExporter-daemonset.yaml b/manifests/monitoring/manifests/nodeExporter-daemonset.yamlindex e3901b0..a33cd39 100644--- a/manifests/monitoring/manifests/nodeExporter-daemonset.yaml+++ b/manifests/monitoring/manifests/nodeExporter-daemonset.yaml@@ -38,10 +38,11 @@ spec: name: node-exporter resources: limits:- cpu: 250m+ cpu: 500m memory: 180Mi requests:- cpu: 102m+ # cpu: 102m+ cpu: 250m memory: 180Mi volumeMounts: - mountPath: /host/sysOutcome" }, { "title": "Customize the Favicon", "url": "/posts/customize-the-favicon/", "categories": "Blogging, Tutorial", "tags": "favicon", "date": "2019-08-10 16:34:00 +0000", "snippet": "DRAFT4The favicons of Chirpy are placed in the directory assets/img/favicons/. You may want to replace them with your own. The following sections will guide you to create and replace the default favicons.Generate the faviconPrepare a square image (PNG, JPG, or SVG) with a size of 512x512 or more, and then go to the online tool Real Favicon Generator and click the button Select your Favicon image to upload your image file.In the next step, the webpage will show all usage scenarios. You can keep the default options, scroll to the bottom of the page, and click the button Generate your Favicons and HTML code to generate the favicon.Download &amp;amp; ReplaceDownload the generated package, unzip and delete the following two from the extracted files: browserconfig.xml site.webmanifestAnd then copy the remaining image files (.PNG and .ICO) to cover the original files in the directory assets/img/favicons/ of your Jekyll site. If your Jekyll site doesn’t have this directory yet, just create one.The following table will help you understand the changes to the favicon files: File(s) From Online Tool From Chirpy *.PNG ✓ ✗ *.ICO ✓ ✗ ✓ means keep, ✗ means delete.The next time you build the site, the favicon will be replaced with a customized edition." }, { "title": "Hello world!", "url": "/posts/hello-world/", "categories": "jekyll, blogging", "tags": "foo, bar", "date": "2018-10-13 03:51:02 +0000", "snippet": "Hello world, this is my first Jekyll blog post.Figuring out how to do this on github pages.class test { string hello;}Also looking at editing workflowsWorking Copy and 1writer seems like a pretty great combo. Amazing." } ]
